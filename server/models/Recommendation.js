/**
 * Recommendation Model
 * 
 * Stores personalized house recommendations for users
 * Generated by the recommendation engine based on user preferences,
 * browsing history, and similar users' choices
 * 
 * Features:
 * - Multiple recommendation algorithms support
 * - Score tracking for ranking
 * - Refresh timestamps
 */

const mongoose = require('mongoose');

// Sub-schema for individual recommendations
const recommendedHouseSchema = new mongoose.Schema({
  houseId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'House',
    required: true
  },
  // Match score (0-100)
  matchScore: {
    type: Number,
    min: 0,
    max: 100,
    default: 0
  },
  // Reasons for recommendation
  reasons: [{
    type: String,
    enum: [
      'price_match',
      'location_match',
      'amenities_match',
      'rooms_match',
      'similar_users',
      'trending',
      'highly_rated',
      'recently_viewed',
      'owner_verified',
      'quick_availability'
    ]
  }],
  // Whether user has viewed this recommendation
  viewed: {
    type: Boolean,
    default: false
  },
  viewedAt: Date,
  // Whether user interacted (clicked, saved, etc.)
  interacted: {
    type: Boolean,
    default: false
  }
}, { _id: false });

const recommendationSchema = new mongoose.Schema({
  // User receiving recommendations
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Recommendation must belong to a user']
  },
  // List of recommended houses with scores
  recommendedHouses: [recommendedHouseSchema],
  // Algorithm used for generation
  algorithm: {
    type: String,
    enum: [
      'content_based',      // Based on house attributes matching preferences
      'collaborative',      // Based on similar users' choices
      'hybrid',             // Combination of content and collaborative
      'trending',           // Based on popularity/views
      'location_based',     // Based on user's preferred locations
      'smart_match'         // Uses the smart match score utility
    ],
    default: 'hybrid'
  },
  // Overall quality/confidence score
  confidenceScore: {
    type: Number,
    min: 0,
    max: 100,
    default: 50
  },
  // When recommendations were last refreshed
  refreshedAt: {
    type: Date,
    default: Date.now
  },
  // Whether recommendations are stale and need refresh
  stale: {
    type: Boolean,
    default: false
  },
  // User feedback on recommendations
  feedback: {
    helpful: { type: Number, default: 0 },
    notHelpful: { type: Number, default: 0 }
  }
}, {
  timestamps: true
});

// Indexes for faster queries
recommendationSchema.index({ userId: 1 });
recommendationSchema.index({ refreshedAt: -1 });
recommendationSchema.index({ stale: 1 });

/**
 * Static method to get or create recommendations for a user
 * @param {string} userId - User ID
 * @returns {Promise<Recommendation>}
 */
recommendationSchema.statics.getForUser = async function(userId) {
  let recommendations = await this.findOne({ userId })
    .populate({
      path: 'recommendedHouses.houseId',
      select: 'title price rooms location images averageRating verified available',
      match: { available: true }
    });

  // If no recommendations exist or they're stale, mark for refresh
  if (!recommendations) {
    recommendations = new this({ userId, recommendedHouses: [], stale: true });
    await recommendations.save();
  }

  return recommendations;
};

/**
 * Static method to mark user's recommendations as stale
 * Called when user updates preferences
 * @param {string} userId - User ID
 */
recommendationSchema.statics.markStale = async function(userId) {
  return this.updateOne({ userId }, { stale: true });
};

/**
 * Instance method to add new recommendations
 * @param {Array} houses - Array of { houseId, matchScore, reasons }
 */
recommendationSchema.methods.addRecommendations = async function(houses) {
  // Clear existing recommendations
  this.recommendedHouses = houses.map(h => ({
    houseId: h.houseId,
    matchScore: h.matchScore || 0,
    reasons: h.reasons || [],
    viewed: false,
    interacted: false
  }));

  this.refreshedAt = new Date();
  this.stale = false;

  return this.save();
};

/**
 * Instance method to mark a house as viewed
 * @param {string} houseId - House ID that was viewed
 */
recommendationSchema.methods.markViewed = async function(houseId) {
  const house = this.recommendedHouses.find(
    h => h.houseId.toString() === houseId.toString()
  );

  if (house) {
    house.viewed = true;
    house.viewedAt = new Date();
    await this.save();
  }

  return this;
};

/**
 * Instance method to mark a house as interacted
 * @param {string} houseId - House ID that was interacted with
 */
recommendationSchema.methods.markInteracted = async function(houseId) {
  const house = this.recommendedHouses.find(
    h => h.houseId.toString() === houseId.toString()
  );

  if (house) {
    house.interacted = true;
    await this.save();
  }

  return this;
};

/**
 * Instance method to record feedback
 * @param {boolean} isHelpful - Whether recommendations were helpful
 */
recommendationSchema.methods.recordFeedback = async function(isHelpful) {
  if (isHelpful) {
    this.feedback.helpful += 1;
  } else {
    this.feedback.notHelpful += 1;
  }

  return this.save();
};

/**
 * Get top N recommendations sorted by match score
 * @param {number} limit - Number of recommendations to return
 */
recommendationSchema.methods.getTopRecommendations = function(limit = 10) {
  return this.recommendedHouses
    .filter(h => h.houseId && h.houseId.available !== false)
    .sort((a, b) => b.matchScore - a.matchScore)
    .slice(0, limit);
};

module.exports = mongoose.model('Recommendation', recommendationSchema);
